%05-conclusion.tex

\chapter{Conclusion}
With this thesis, we showed that LLHD is fully representable in MLIR (and that our representation is correct) by defining an LLHD dialect and correctly simulating various real-world designs represented in it.
Furthermore, our first implementation of the MLIR-based simulator already comes close to competitive performance. In particular, our simulator manages to surpass a well-established commercial simulator for some test cases, running up to $1.5$ times faster and otherwise only $3.2$ times slower on average. This while being a very young and poorly optimized sequential implementation.
We also showed that the performance losses in our implementation mainly reside in the runtime library and simulator engine, and not in the execution of the lowered LLHD code, making the simulator a good optimization target with high speed-up potential. The small set of optimization we could implement already shows the massive performance speed-up potential present in our simulator. We are confident that further exploration of LLHD-based simulation could enable a new and open-source standard in HDL simulation and verification.

%---------------------------------------------------------------------------------------------------

\section{Related Work}
Various open-source HDL simulators exist on the market, but, to our knowledge, none has support for the SystemVerilog standard as vast as LLHD, or does not support SystemVerilog or VHDL at all. Here we list some of the most popular and well-documented open-source alternatives available.

%-------------------------------------------------------------------------------

\subsection{Verilator}
\textit{Verilator} \cite{verilator} is a popular open-source simulator. It profits from high simulation speeds by compiling SystemVerilog designs into single- or multi-threaded \textit{C++} code, though, mainly synthesizable constructs are accepted. This means that SystemVerilog test-benches cannot be simulated using Verilator as they generally contain unsynthesizable constructs. Instead, the user is expected to write a \textit{C++/SystemC} wrapper around the design under test, (re-)implementing the test-bench. An important distinction that sets Verilator apart from our approach is that Verilator does not have any support for explicit delays, often throwing an error if one is encountered, or otherwise ignoring it.

% \section{Lifting}
% The Lifting \cite{Bosio2008} offers both behavioral and fault simulation, though it is more focused on the latter.

%-------------------------------------------------------------------------------

\subsection{SystemC and Cascade}
\textit{SystemC} \cite{systemc} and \textit{Cascade} \cite{Grossman2013}  bothe define a \textit{C++} library used to model hardware designs. The \textit{C++} constructs can then be used as simulation interfaces, and usually be compiled into an executable performing the simulation.

These approaches, though, do not interface with SystemVerilog or VHDL, but rather expect the designs to be directly implemented through the \textit{C++} constructs. For example, SystemC is often considered as a standalone HDL (though it is \textit{C++}) and even takes a spot in Wikipedia's list of HDLs\footnote{\url{https://en.wikipedia.org/wiki/Hardware_description_language\#Examples_of_HDLs}}.

Cascade also takes a cycle-based simulation approach, in contrast to both our approach and SystemC's. This means that simulation state updates are no longer processed on an event-basis, where the time granularity is defined by the events themselves, but rather on fixed clock cycles. Furthermore, Cascade offers Verilog co-simulation, but this is mainly to support Verilog test-benches, rather than entire Verilog designs.

%-------------------------------------------------------------------------------

\subsection{Icarus Verilog and OSS CVC}
\textit{Icarus Verilog} \cite{icarus} and the \textit{OSS CVC} Verilog compiler \cite{Meyer2016}, to our knowledge, are the two open-source simulation toolchains that most closely resemble our simulation approach.

Icarus Verilog is an open-source implementation of Verilog, mainly focusing on simulation, but also providing support for synthesis. Different from LLHD, though, it focuses on the IEEE Std 1364-2005 Verilog standard \cite{V2006}, with only limited support for the SystemVerilog standard. Most notably, it does not accept any of the examples from our test set. It is otherwise very similar to LLHD's workflow: the input design is first compiled to an intermediate representation, called \textit{vpp}, which can be used for either simulation (through the \textit{vpp} tool) or synthesis.

OSS CVC, on the other hand, compiles Verilog designs directly to x86 machine code and then uses an event-driven approach to simulate the input design. As for Icarus Verilog though, it is only limited to the IEEE Std 1364-2005 Verilog standard, precluding the use of the higher-level SystemVerilog extensions.

%---------------------------------------------------------------------------------------------------

\section{Future Work}
We think our first implementation opens up many interesting research questions that could be explored in the future, including:

\begin{itemize}
  \item Though initially planned for this thesis, we did not manage to explore what speed-ups we could obtain through a multi-threaded simulation approach. Considering that a significant amount of time in our simulation is spent in creating events, we think adopting a simple  \textit{Centralized-Queue} algorithm \cite{Ashenden1994} could already bring significant performance improvements, by splitting that phase over multiple threads.
  \item We did not explore what optimizations and performance improvements other MLIR dialects and transformations could enable, but rather directly lower from LLHD to the LLVM dialect, only optimizing the generated LLVM IR code through the provided “O“ flags. Especially with the rise of the CIRCT project, and other hardware-targeted dialects, it will pose an interesting question of what performance improvements they could bring to LLHD simulation.
  \item Introducing static analysis of the input design could potentially bring significant performance improvements. For example, the input design could be analyzed to preemptively allocate the memory buffers necessary to store the various signal updates in the event queue, reducing the costs of dynamic memory allocation. Further analysis could potentially completely avoid the execution of parts of the input design that have no visible effects on the execution. \Eg, consider two processes $A$ and $B$. If $B$'s signal updates always obscure $A$'s updates, then $A$ does not affect the overall behavior of the design, and its execution can be avoided.
  \item Both the LLHD dialect and LLVM dialect mapping are not complete. \Eg, introducing support for logic types would enable us to generate $100\%$ matching traces when compared against commercial simulators.
        % \item We provided only a limited comparison of our performance results, only comparing it against one commercial simulator. This choice was mainly due to the missing availability of other commercial tools on our testing machine and time constraints. More complete benchmarking and comparison of the current and future implementations of our simulator against a broader range of commercial simulators could give us a clearer picture of the potential of this HDL simulation approach.
\end{itemize}



